#!/usr/bin/env node
import*as g from"fs";import*as i from"path";import*as d from"url";import{transformSync as y}from"esbuild";let p={baseUrl:null,paths:{},tsconfigDir:null};function x(t){p=t}function L(){const{baseUrl:t,tsconfigDir:e}=p;return t?i.resolve(e??process.cwd(),t):null}async function h(t,e){const s=i.resolve(t,e),c=[s,s+".ts",s+".tsx",i.join(s,"index.ts"),i.join(s,"index.tsx")];for(const a of c)try{if(g.existsSync(a)&&g.statSync(a).isFile())return{url:d.pathToFileURL(a).href}}catch{}throw Object.assign(new Error(`Cannot find module '${e}'`),{code:"ERR_MODULE_NOT_FOUND"})}async function P(t,e,s){let c=process.cwd();if(e.parentURL&&(c=i.dirname(d.fileURLToPath(e.parentURL))),t.startsWith("file://")){const o=d.fileURLToPath(t),n=i.dirname(o),u=i.basename(o),r=(i.extname(u),u);return{...await h(n,r),shortCircuit:!0}}if(t.startsWith(".")||t.startsWith("/"))return{...await h(c,t),shortCircuit:!0};{const{paths:o}=p,n=L();for(const r of Object.keys(o)){let l=null;const f=r.endsWith("/*"),v=f?r.slice(0,-2):r;if(f&&t.startsWith(v+"/")?l=t.slice(v.length+1):!f&&t===r&&(l=""),l!==null)for(const R of o[r]){const U=f?R.replace(/\*/g,l):R;if(n)try{return{...await h(n,U),shortCircuit:!0}}catch(m){if(m.code!=="ERR_MODULE_NOT_FOUND")throw m}}}if(n)try{return{...await h(n,t),shortCircuit:!0}}catch(r){if(r.code!=="ERR_MODULE_NOT_FOUND")throw r}return{...await s(t,e),shortCircuit:!0}}}async function w(t,e,s){if(!t.endsWith(".ts")&&!t.endsWith(".tsx"))return s(t,e);const c=t.endsWith(".tsx")?"tsx":"ts",a=d.fileURLToPath(t),o=g.readFileSync(a,"utf8"),{code:n}=y(o,{loader:c,format:"esm",target:`node${process.versions.node}`,sourcemap:"inline",sourcefile:a,banner:`
import { createRequire } from 'module';
const require = createRequire(import.meta.url);`});return{format:"module",source:n,shortCircuit:!0}}export{x as initialize,w as load,P as resolve};
